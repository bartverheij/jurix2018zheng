\documentclass{IOS-Book-Article}
\usepackage{amssymb}
\usepackage{array}

\usepackage{graphics}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{color}
\usepackage{tabularx}
\usepackage{supertabular}
\usepackage{longtable}
\usepackage{natbib}
\usepackage{enumerate}
\usepackage{changepage}
\usepackage{enumitem}
\setenumerate[1]{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=0pt}
\setitemize[1]{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=0pt}

%for images
\usepackage{tikz}
\usetikzlibrary{positioning,shapes,arrows,arrows.meta,decorations.markings}

\DeclareFixedFont{\mf}{T1}{cmbr}{m}{n}{10pt}

\lstset{ %
  language=Octave,                 % the language of the code
  basicstyle=\tiny,            % the size of the fonts that are used for the code
 %numbers=left,                    % where to put the line-numbers
 %numberstyle=\tiny\color{gray},   % the style that is used for the line-numbers
  stepnumber=2,                    % the step between two line-numbers. If it's 1,  each line 
                                  % will be numbered
  numbersep=5pt,                   % how far the line-numbers are from the code
  backgroundcolor=\color{white},       % choose the background color. You must add \usepackage{color}
  showspaces=false,                % show spaces adding particular underscores
  showstringspaces=false,          % underline spaces within strings
  showtabs=false,                  % show tabs within strings adding particular underscores
  frame=single,                    % adds a frame around the code
  rulecolor=\color{black},         % if not set,  the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                       % sets default tabsize to 2 spaces
  captionpos=b,                    % sets the caption-position to bottom
  breaklines=true,                 % sets automatic line breaking
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  title=\lstname,                    % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
%  keywordstyle=\color{blue},           % keyword style
%  commentstyle=\color{dkgreen},        % comment style
 % stringstyle=\color{mauve},          % string literal style
  escapeinside={\%*}{*)},             % if you want to add LaTeX within your code
  morekeywords={*, ...}               % if you want to add more keywords to the set
}





\begin{document}

\pagestyle{headings}
\def\thepage{}

\begin{frontmatter} 

\title{Checking the validity of rule-based arguments grounded in cases: \\a computational approach}

%\markboth{}{September 2018\hb}
%\subtitle{Subtitle}

\author[A]{\fnms{Heng} \snm{Zheng}\thanks{Corresponding Author: Artificial Intelligence, University of Groningen, The Netherlands; E-mail:zhengh48@mail2.sysu.edu.cn.}}, \author[B]{\fnms{Minghui} \snm{Xiong}} and \author[A]{\fnms{Bart} \snm{Verheij}}

\runningauthor{H. Zheng et al.}
\address[A]{Artificial Intelligence, University of Groningen, The Netherlands}
\address[B]{Institute of Logic and Cognition, Sun Yat-sen University, Guangzhou, China}

\begin{abstract}
Legal justice needs judges' decisions to be rational and reasonable in the sense that arguments are based on rules and grounded in cases.  One puzzle studied in AI \& Law is how arguments, rules and cases are formally connected. Recently a formal theory was proposed formalizing how the validity of arguments based on rules can be grounded in cases. Three kinds of argument validity were distinguished: coherence, presumptive validity and conclusiveness. In this paper the theory is implemented in a Prolog program, used to evaluate a previously developed model of Dutch tort law. We also test the theory and its implementation with a new case study modeling Chinese copyright infringement law. In this way we illustrate that by the use of the implementation the process of modeling becomes more efficient and less error-prone.
\end{abstract}

\begin{keyword}
Artificial Intelligence and Law\sep Rule-based Reasoning\sep Case-based Reasoning\sep Argumentation Modeling\sep Prolog
\end{keyword}
\end{frontmatter}
%\markboth{September 2018\hb}{September 2018\hb}

\section{Introduction}
\noindent 
In the field of AI and law---going at least back to the 1970s \cite{Buchanan1970Some}---, scholars usually follow three approaches to develop legal reasoning systems, which are rule-based reasoning, case-based reasoning and argument-based reasoning. In the 1980s, the British Nationality Act (BNA) was implemented in Prolog~\citep{Sergot1986The}, in a successful attempt to develop rule-based reasoning systems in the field of law. Case-based reasoning was modeled in the systems HYPO, BankXX, CATO and IBP~\citep{risslandAshley1987,Ashley1991Reasoning,Rissland1996BankXX,Aleven1997Evaluating,Bruninghaus2003Predicting}. 
CABARET \citep{Rissland1991CABARET} and GREBE \citep{Branting1991Building} are hybrid systems not only use case-based reasoning, but also other kinds of reasoning. 
Argumentation models of legal rule-based and case-based reasoning~\citep{prakkenSartor1996,prakkenSartor1998} are connected to later systems based on abstract argumentation~\citep{Dung1995On}, inspiring for instance ASPIC+ \citep{Prakken2010An}, ABA \citep{Bondarenko1997An} and DeLP \citep{Garcia2003Defeasible}.

The recent case model formalism \citep{Verheij2016Correct} is a hybrid theory showing connections between cases, rules and arguments~\citep{Verheij2017Formalizing}. The formalism defines different ways in which rule-based arguments can be valid in cases: arguments can be coherent, conclusive or presumptive. The formalism has been applied to model Dutch tort law, showing how a rule-based legal domain can be grounded in legal cases. In this way, a formal connection is established between the civil law tradition focusing on rules and the common law tradition focusing on cases. The formalism has also been applied to the modeling of a series of New York tort cases (as studied by~\cite{bermanHafner1995,hafnerBerman2002}), analyzing value-guided teleological reasoning~\citep{Verheij2016Formalizing}.

The present paper provides a computational version of the case model formalism. A Prolog program is presented that can computationally check whether a case model is correct, whether rule-based arguments are valid (in the three kinds of validity coherence, conclusiveness and presumptiveness), and whether defeating circumstances are rebutting, undercutting or undermining. The computational tool can be used to support the manual modeling of a complex legal domain, making that more manageable. As an example, we provide a new domain model, namely Chinese copyright infringement law, both formally (as a case model) and computationally (in Prolog).

\section{The case model formalism}
\label{sec:cm}

\noindent The case model formalism was introduced in \citep{Verheij2016Correct}. The formalism uses a classical formal logical  language $L$ generated from a finite set of propositional constants in a standard way writing $\neg$ for negation, $\wedge$ for conjunction, $\vee$ for disjunction, $\leftrightarrow$ for equivalence, $\top$ for a tautology, and $\bot$ for a contradiction. The associated classical, deductive, monotonic consequence relation is denoted $\vDash$.  

Case models formalize cases and their ordering. The cases in a case model must be logically consistent, mutually incompatible and different; and the comparison relation must be total and transitive. Here follow the core definitions.

\textbf{Definition 2.1}: A \textit{case model} is a pair $(C,  \geq)$ with finite $C \in L$, such that the following hold, for all $\varphi$, $\psi$ and $\chi \in C$: 
\begin{enumerate}
\item $\not \vDash \neg \varphi$;
\item If $\not \vDash \varphi \leftrightarrow \psi$, then $\vDash \neg$ ($\varphi \wedge \psi$);
\item If $\vDash \varphi \leftrightarrow \psi$, then $\varphi = \psi$;
\item $\varphi \geq \psi$ or $\psi \geq \varphi$;
\item If $\varphi \geq \psi$ and $\psi \geq \chi$, then $\varphi \geq \chi$.
\end{enumerate}

\textbf{Definition 2.2} (\textit{Arguments}) An \textit{argument} is a pair $(\varphi, \psi)$ with $\varphi$ and $\psi \in L$. The sentence $\varphi$ expresses the argument's premises, the sentence $\psi$ its conlusions, and the sentence $\varphi \wedge \psi$ the \textit{case made} by the arguments. Generalizing, a sentence $\chi \in L$ is a \textit{premise} of the argument when $\varphi \vDash \chi$, a \textit{conclusion} when $\psi \vDash \chi$, and a \textit{position} in the case made by the argument when $\varphi \wedge \psi \vDash \chi$. An argument $(\varphi, \psi)$ is \textit{(properly) presumptive} when $\varphi \not \vDash \psi$; otherwise \textit{not-presumptive}. An argument $(\varphi, \psi)$ is a \textit{presumption} when $\vDash \varphi$, i.e., when its premises are logically tautologous.

\textbf{Definition 2.3} \textit{(Coherent arguments)} Let $(C,  \geq)$ be a case model. Then we define, for all $\varphi$ and $\psi \in L$:

$(C,  \geq) \vDash (\varphi,  \psi)$ if and only if $\exists \omega \in C: \omega \in \varphi \wedge \psi$.

We then say that the argument from $\varphi$ to $\psi$ is \textit{coherent} with respect to the case model.

\textbf{Definition 2.4} (\textit{Conclusive arguments}) Let $(C,  \geq)$ be a case model. Then we define, for all $\varphi$ and $\psi \in L$:

$(C,  \geq) \vDash \varphi \Rightarrow \psi$ if and only if $\exists \omega \in C: \omega \in \varphi \wedge \psi$ and $\forall \omega \in C$: if $\omega \in \varphi$, then $\omega \in \varphi \wedge \psi$.

We then say that the argument from $\varphi$ to $\psi$ is \textit{conclusive} with respect to the case model.

\textbf{Definition 2.5} (\textit{Presumptively valid arguments}) Let $(C,  \geq)$ be a case model. Then we define, for all $\varphi$ and $\psi \in L$:

$(C,  \geq) \vDash \varphi \leadsto \psi$ if and only if $\exists \omega \in C$:

1. $\omega \vDash \varphi \wedge \psi$; and

2. $\forall \omega' \in C$: if $\omega' \vDash \varphi, $ then $\omega \geq \omega'$.

We then say that the argument from $\varphi$ to $\psi$ is \textit{(presumptively) valid} with respect to the case model.

\textbf{Definition 2.6} (\textit{Successful attack}) Let $(C,  \geq)$ be a case model, and $(\varphi, \psi)$ a presumptively valid argument. Then circumstances $\chi$ are \textit{defeating} or \textit{successful attacking} the argument when $(\varphi \wedge \chi, \psi)$ is not presumptively valid. We write $(C,  \geq) \vDash \varphi \leadsto \psi \times \chi$. Defeating circumstances are \textit{excluding} when $(\varphi \wedge \chi, \psi)$ is not coherent. A case $\omega \in C$ provides grounding for the attack if $\omega \vDash \varphi \wedge \chi$.

\textbf{Definition 2.7} (\textit{Rebutting attack}) When circumstance $\chi$ successfully attack presumptively valid argument $(\varphi, \psi)$, the circumstances are rebutting when $(\varphi \wedge \chi, \neg \psi)$ is presumptively valid.

\textbf{Definition 2.8} (\textit{Undercutting attack}) When circumstances $\chi$ successfully attack presumptively valid argument $(\varphi, \psi)$, and are not rebutting, the circumstances are \textit{undercutting}.

\textbf{Definition 2.9} (\textit{Undermining attack}) When circumstances $\chi$ successfully attack a presumption $(\top, \varphi)$, the circumstances are \textit{undermining}.

\section{Implementation in Prolog}
\noindent We have implemented the case model formalism in Prolog. We use the previously developed model of Dutch tort law~\cite{Verheij2017Formalizing} as an illustration. Cases are represented as Prolog lists, of which the elements consist of strings and their negations (represented using {\mf not/1}). For instance, {\mf [not(dut),dmg,unl,imp,not(cau)]} represents the case in which there is no duty ({\mf not(dut)}) to repair the damages ({\mf dmg}) although the act is unlawful ({\mf unl}) and imputable ({\mf imp]}), but there is no causality ({\mf not(cau)}). Case models are represented as lists of cases and their ordering, where case models and cases are referred to using identifiers. 
	\begin{lstlisting}[caption={Definition of the Dutch tort law case model in Prolog},captionpos=b,float]
	case(model_num(1),case_num(101),[not(dmg)]).
	...
	case(model_num(1),case_num(104),[not(dut),dmg,unl,imp,not(cau)]).
	case(model_num(1),case_num(105),[dut,dmg,unl,imp,cau,vrt,not(vst),not(vun),ift,not(ila),not(ico),not(jus),prp]).
	...
	case(model_num(1),case_num(114),[not(dut),dmg,not(unl),vrt,not(vst),jus]).
	...
	case_order(model_num(1),[case_num(101),case_num(102),case_num(103),case_num(104),[case_num(105),case_num(106),...,case_num(113)],...]).
	\end{lstlisting}

Listing 1 provides a part of the representation of the case model for Dutch tort law ({\mf model\_num(1)}). 
The representation of the case model starts with a series of definitions of cases followed by the ordering. Here {\mf case\_num(104)} is the non-causality case just discussed. The full model consists of the 16 cases discussed in~\cite{Verheij2017Formalizing}. The ordering is represented as a list of cases and lists of cases, each representing an equivalence class of the total preorder, in decreasing level of preference. Hence the first element of this list represents the case or cases that are maximal in the total preorder. Here there is one maximal case {\mf case\_num(101): not(dmg)}, representing that there are no damages. When an equivalence class consists of several cases, such as {\mf [case\_num(105),...,case\_num(113)]}, it is represented as a list of cases (actually: of case identifiers).

The predicate {\mf case\_model\_valid/1} (with a case identifier as single argument) checks whether a case model fulfills the definition, i.e. whether all cases are consistent, incompatible and different (cf. Definition 2.1 above). Consistency is determined by checking whether a case contains an element and its negation. For instance, a case {\mf [not(dmg), dmg]} would not be consistent. This straightforward way of consistency checking is allowed by our use of a language of elementary literals instead of a full propositional language. Incompatibility is checked by determining for every pair of cases whether there is an element in one case of which the negation is in the other. For instance, cases 
{\mf case\_num(101): not(dmg)} and 
{\mf case\_num(104): not(dut),dmg,...} can be distinguished by {\mf not(dmg)} and {\mf dmg}, hence are incompatible. Difference is checked by determining for every pair of cases whether there is an element in one case that is not in the other. Note that a pair of incompatible cases implies that they are different. Checking elements 4 and 5 in the formal definition of case models is not directly represented since we use an explicit representation of the total preorder as a list of equivalence classes. In this representation another validity check is helpful, namely whether each case of which an identifier appears in the ordering is defined and whether each case identifier of a defined case appears in the ordering exactly once. This check has been implemented using the predicate {\mf ordering\_valid/1}.

Arguments are represented by a list of premises and a list of conclusions. For instance, {\mf argument([dmg,unl,imp,cau],[dut])} represents the argument to the one-element conclusion that there is a duty to repair the damages ({\mf dut}) from the four-element premises that there are damages ({\mf dmg}) by an unlawful act ({\mf unl}) that is imputable ({\mf imp}) to the actor and that has caused the damages ({\mf cau}).

The three kinds of validity of arguments can be checked using the predicates {\mf coherent/1}, {\mf conclusive/1} and {\mf presumptively\_valid/1}, each taking an argument (represented using {\mf argument/2}) as input. Coherence is checked by first determining the case made by an argument, found by appending the list of premises to the list of conclusions, and then checking whether there is a case in the case model that contains all elements of the case made by the argument. For instance, {\mf argument([dmg,unl,imp,cau],[dut]))} is coherent by the case with identifier {\mf 105} whereas {\mf argument([dmg],[not(dmg)])} is not as its case made is not consistent.

The conclusiveness of an argument is checked by first checking whether the argument is coherent and then checking, if all cases in the case model that contain the argument's premises also contain its conclusions. For instance, {\mf argument([dmg],[dut])} is coherent (e.g., by case {\mf 105}) but not conclusive (by case {\mf 104}). The argument {\mf argument([dut],[dmg])} is conclusive since it is coherent (e.g., by {\mf 105}) and indeed all cases of {\mf dut} are also cases of {\mf dmg}.

Presumptive validity of an argument is checked by first determining a maximally preferred case that witnesses the argument's coherence (i.e., finding a case in which both the premises and the conclusions of the argument hold and that is maximal in the ordering with this property) and then checking for each case in which the argument's premises hold whether such a witnessing case is of equal or lower ordering. For instance, {\mf argument([vrt],[unl])} is presumptively valid since for instance case {\mf 105} is a case of maximal ordering that shows the arguments coherence, and there is no case of the premises that is higher in the ordering. The coherent argument {\mf argument([vrt],[not(unl)])} is not presumptively valid since maximally ordered cases that show the coherence of the argument (such as case {\mf 114}) are not maximal among the cases in which the premises hold (e.g., case {\mf 105} is higher in the ordering).

Attack of arguments has been implemented using the predicates {\mf successful\_attack/2}, {\mf rebutting\_attack/2}, {\mf undercutting\_attack/2} and {\mf undermining\_attack/2}. The predicate {\mf successful\_attack/2} takes an argument and defeating circumstances (as a list) as input. The predicate checks whether the argument is presumptively valid and whether the argument to the same conclusions but from the premises with the defeating circumstances appended is also presumptively valid. For instance, since {\mf argument([vrt],[unl])} is presumptively valid, while {\mf argument([vrt, jus],[unl])} is not (it is not even coherent), the Prolog query {\mf ?-- successful\_attack(argument([vrt],[unl]), [jus])} returns {\mf true} as an answer.

The three kinds of attack---rebutting, undercutting and undermining---are defined in terms of successful attack as follows. Rebutting attack requires a successful attack of an argument such that also the argument from the premises to the opposite of the argument's conclusion is presumptively valid. Note that this only makes sense for arguments with a single element as conclusion as we use no Prolog expression for the negation of a series of conclusions. For instance, {\mf rebutting\_attack(argument([vrt],[unl]), [jus])} holds since it represents a successful attack and also argument([vrt],[not(unl)]) is presumptively valid. Successful attacks that are not rebutting attacks are undercutting. Undermining attack is a special kind of successful attack, namely an attack of an argument with a tautology as premise. In the program, a tautology is represented as an empty Prolog list {\mf [ ]}.

The Prolog program can be used to validate hand-made domain models, such as the case model for Dutch tort law of~\cite{Verheij2017Formalizing}. In Figure~\ref{fig:tort}, we show the argument structure that is valid in the hand-made formal case model of that paper (left). On the right, we show Prolog clauses that all evaluate to true given the Prolog version of that case model (partially shown in Listing 1). Each supporting arrow (with a normal arrow head) evaluates as a presumptively valid argument, as expected, some even more strongly as a conclusive argument. Each attacking arrow (ending in a cross) evaluates as a successful attack, in fact all attacks in this model are rebutting attacks. In other words, the model is computationally validated.

\begin{figure*}[btp]
	%\centering
	\scalebox{0.7}{\input{img/tort.tex}}
\caption{The Dutch tort law model: argument structure (left); in Prolog (right)}
\label{fig:tort}
\end{figure*}


\section{Case study: Copyright infringement in Chinese Criminal Law}

%FIRST: Explain the law informally

%SECOND: Show arguments + attacks and the associated case model

%THIRD: Show the Prolog implementation, in particular: show the validity of the arguments + attacks

\noindent The article of Copyright Infringement in Chinese Criminal Law~\cite{StateCouncil2015series} is below:
\newline

\footnotesize
\begin{adjustwidth}{0.5cm}{0cm}
\noindent \textbf{Article 217} Whoever, for the purpose of making profits, commits any of the following acts of infringement on copyright shall, if the amount of illegal gains is relatively large, or if there are other serious circumstances, be sentenced to fixed-term imprisonment of not more than three years or criminal detention and shall also, or shall only, be fined; if the amount of illegal gains is huge or if there are other especially serious circumstances, he shall be sentenced to fixed-term imprisonment of not less than three years but not more than seven years and shall also be fined:

\noindent (1) reproducing and distributing a written work, musical work, motion picture, television programme or other visual works, computer software or other works without permission of the copyright owner;

\noindent (2) publishing a book of which the exclusive right of publication is enjoyed by another person;

\noindent (3) reproducing and distributing an audio or video recording produced by another person without permission of the producer; or

\noindent (4) producing or selling a work of fine art with forged signature of another painter.\newline
\end{adjustwidth}

\normalsize
\noindent 
In Art. 217, there are 4 kinds of act in copyright infringement, if someone violates other people's copyright for the purpose of making profits, then he will be sentenced to the crime of copyright infringement. The judge will sentence the person to one of 4 different kinds of punishment according to the degree of severity of his crime. According to the articles related to Art. 217 in Chinese criminal law~\cite{StateCouncil2015series}, and relevant official judicial interpretations~\cite{SupremeCourt2011Judicial}, there are 3 defeating circumstances: 1. The action is not ``without permission of the copyright owner"; 2. The defendant is sentenced to the crime of copyright infringement, however, he also satisfies with the conditions of being given a heavier punishment; 3. The defendant is sentenced to the crime of copyright infringement, however, he also satisfies with the conditions of being given a lighter punishment.


\begin{table}[t]
	\tiny
	\caption{Elementary propositions in the copyright infringement model; with abbreviations}
	\label{tab:long}
	\begin{tabularx}{\textwidth}{p{0.5cm}|p{11cm}}
		\hline
		ifg & there is a copyright infringement\\
		fpp & the act was for the purpose of making profits\\
		rad & the act was reproduced and distributed\\
		ite & the act concerned the items in Art. 217:1\\
		pco & the act was without permission of the copyright owner\\
		npo & the act was not "without permission of the copyright owner"\\
		epr & the act was publishing a book of which the exclusive right of publication is enjoyed by another person\\
		avp & the act was audio or video recording produced by another person without permission of the producer\\
		psa & the act was producing or selling a work of fine art with forged signature of another painter\\
		ils & the amount of illegal gains is large or other serious circumstances\\
		ihe & the amount of illegal gains is huge or other especially serious circumstances\\
		crc & the person commits the crime of copyright infringement\\
		l3fti & the person shall be sentenced to fixed-term imprisonment of at most three years\\
		cdt & the person shall be sentenced to criminal detention\\
		fin & the person shall be fined\\
		m3fti & the person shall be sentenced to fixed-term imprisonment of not less than three years but not more than seven years\\
		hps & there is a reason which will give the defendant a heavier punishment\\
		lps & there is a reason which will give the defendant a lighter punishment\\
		cpb & the defendant satisfies the conditions of probation\\
		pbt & the defendant will be put on probation\\
		\hline
	\end{tabularx}
\end{table}
\normalsize

In the light of Art. 217 and the judicial interpretations related to it, a case model can be built. 
In our copyright infringement model, we use the elementary propositions in \mbox{Table}~\ref{tab:long}, shown with their formal abbreviations. 
The full model has 46 cases. A selection of the cases is shown in its Prolog version in Listing~2. The model has identifier {\mf model\_num(2)}. 
In the text below, cases are numbered 1, 2, 3, ... corresponding  to cases {\mf 201, 202, 203, ...} in the Prolog version.
Case 1 is built by the principle of ``presumption of innocence". Case 2 is for the first defeating circumstance mentioned above. Case 3 shows the scenario that the defendant violated someone else's copyright, but he didn't do it for making profits. From Case 3 to Case 13, different punishments for the defendant's action in Art. 217:1 are listed. In the same way, different punishments for the defendant in Art. 217:2, Art. 217:3 and Art. 217:4 are listed in the full case model. Thus Case 14 to Case 46 have similar components with Case 4 to Case 13, except the acts of infringement on copyright are different. In this model, Case 1 is maximal in the ordering, as the ``presumption of innocence" is the starting principle in the process of decision making. Besides, in some situations, the defendant will not be regarded as violating someone else's copyright, for instance, Case 2 and Case 3; hence they appear in second place. The rest of cases in the preferred relation are the specific punishments of copyright infringement, they are less preferred than the cases in first and second place.

From Chinese copyright infringement, we can analyze the argument structure as in the diagram in Figure~\ref{fig:copyright} (left). This argument structure shows multiple rule-based steps and exception-based attacks. The structure is valid in the case model we built, as follows.

\begin{lstlisting}[caption={The Chinese copyright infringement case model in Prolog (selection)},captionpos=b,float]
case(model_num(2),case_num(201),[not(rad),not(ite),not(pco),not(epr),not(avp),not(psa),not(ifg)]).
case(model_num(2),case_num(202),[rad,ite,pco,npo,not(ifg)]).
case(model_num(2),case_num(203),[rad,ite,pco,not(npo),not(epr),not(avp),not(psa),ifg,not(fpp)]).
case(model_num(2),case_num(204),[rad,ite,pco,not(epr),not(avp),not(psa),ifg,fpp,ihe,not(ils),crc,hps,not(lps),not(m3fti),not(l3fti),not(cdt),not(fin)]).
case(model_num(2),case_num(205),[rad,ite,pco,not(epr),not(avp),not(psa),ifg,fpp,ihe,not(ils),crc,not(hps),lps,not(m3fti),not(l3fti),not(cdt),not(fin)]).
case(model_num(2),case_num(206),[rad,ite,pco,not(epr),not(avp),not(psa),ifg,fpp,ihe,not(ils),crc,not(hps),not(lps),m3fti,not(l3fti),not(cdt),fin]).
case(model_num(2),case_num(207),[rad,ite,pco,not(epr),not(avp),not(psa),ifg,fpp,not(ihe),ils,crc,hps,not(lps),not(m3fti),not(l3fti),not(cdt),not(fin)]).
case(model_num(2),case_num(208),[rad,ite,pco,not(epr),not(avp),not(psa),ifg,fpp,not(ihe),ils,crc,not(hps),lps,not(m3fti),not(l3fti),not(cdt),not(fin)]).
case(model_num(2),case_num(209),[rad,ite,pco,not(epr),not(avp),not(psa),ifg,fpp,not(ihe),ils,crc,not(hps),not(lps),not(m3fti),not(l3fti),not(cdt),fin]).
case(model_num(2),case_num(210),[rad,ite,pco,not(epr),not(avp),not(psa),ifg,fpp,not(ihe),ils,crc,not(hps),not(lps),not(m3fti),l3fti,not(cdt),fin,cpb,pbt]).
case(model_num(2),case_num(211),[rad,ite,pco,not(epr),not(avp),not(psa),ifg,fpp,not(ihe),ils,crc,not(hps),not(lps),not(m3fti),not(l3fti),cdt,fin,cpb,pbt]).
case(model_num(2),case_num(212),[rad,ite,pco,not(epr),not(avp),not(psa),ifg,fpp,not(ihe),ils,crc,not(hps),not(lps),not(m3fti),l3fti,not(cdt),fin,not(cpb),not(pbt)]).
case(model_num(2),case_num(213),[rad,ite,pco,not(epr),not(avp),not(psa),ifg,fpp,not(ihe),ils,crc,not(hps),not(lps),not(m3fti),not(l3fti),cdt,fin,not(cpb),not(pbt)]).
...
case_order(model_num(2),[case_num(201),[case_num(202),case_num(203), ...],[case_num(204),case_num(205),case_num(207),case_num(208), ... ,case_num(206),case_num(209),case_num(210),case_num(211),case_num(212),case_num(213), ...]]).
\end{lstlisting}

\begin{figure*}[b]
	\scalebox{0.7}{\input{img/copyright.tex}}
\caption{The Chinese copyright infringement model: argument structure (left); in Prolog (right)}
\label{fig:copyright}
\end{figure*}

Following the definitions of the case model formalism (Section~\ref{sec:cm}), the rule $\textrm{ifg} \wedge \textrm{fpp} \Rightarrow \textrm{crc}$ is indeed valid in this model, in different ways. As the model shows, this argument is coherent, as all cases imply sentence $\textrm{ifg} \wedge \textrm{fpp} \wedge \textrm{crc}$ which is the case made by the argument $(\textrm{ifg} \wedge \textrm{fpp}, \textrm{crc})$. Besides, all the cases which imply the premises $\textrm{ifg} \wedge \textrm{fpp}$, also imply the conclusion $\textrm{crc}$. So argument $(\textrm{ifg} \wedge \textrm{fpp}, \textrm{crc})$ is also conclusive in the case model, and hence it is presumptively valid. And these arguments are also conclusive in the model:

\begin{itemize}
\item $(C,  \geq) \models \textrm{crc} \wedge \textrm{l3fti} \wedge \textrm{fin} \wedge \textrm{cpb} \Rightarrow \textrm{pbt}$
\item $(C,  \geq) \models \textrm{crc} \wedge \textrm{cdt} \wedge \textrm{fin} \wedge \textrm{cpb} \Rightarrow \textrm{pbt}$
\end{itemize}

\noindent Argument $(\textrm{rad} \wedge \textrm{ite} \wedge \textrm{pco}, \textrm{ifg})$ is presumptively valid. In the copyright infringement model, this argument is coherent as Case 2 implies $\textrm{rad} \wedge \textrm{ite} \wedge \textrm{pco} \wedge \textrm{ifg}$, the case made by the argument. As Case 2 is also the strongest case among the cases which imply the premises of this argument, the argument $(\textrm{rad} \wedge \textrm{ite} \wedge \textrm{pco}, \textrm{ifg})$ is presumptively valid in the case model. It is not conclusive, as the defeating circumstance $\textrm{npo}$ successfully attacks the argument. Since the case model makes the argument $(\textrm{rad} \wedge \textrm{ite} \wedge \textrm{pco} \wedge \textrm{npo}, \neg \textrm{ifg})$ presumptively valid, this defeating circumstance is rebutting. In the same way, the following hold in the case model.

\begin{itemize}
\item $(C,  \subseteq) \models \textrm{crc} \leadsto \textrm{ils}$
\item $(C,  \subseteq) \models \textrm{crc} \wedge \textrm{ils} \leadsto \textrm{l3fti} \wedge \textrm{fin} \times \textrm{hps}$
\item $(C,  \subseteq) \models \textrm{crc} \wedge \textrm{ils} \leadsto \textrm{cdt} \wedge \textrm{fin} \times \textrm{hps}$
\item $(C,  \subseteq) \models \textrm{crc} \wedge \textrm{ihe} \leadsto \textrm{m3fti} \wedge \textrm{fin} \times \textrm{lps}$
\end{itemize}

\noindent The Prolog program confirms the validity of the arguments above. Figure 2 (right) lists Prolog queries evaluated as true, which means the results of the Prolog program correspond to our analysis of the Chinese copyright infringement model.

\section{Discussion and Conclusion}

\noindent 
The Prolog program we introduced in this paper can support the process of modeling legal domains and its main function is automatically verifying the validity of the arguments implicated in a case model and the case model itself. This program has been shown to be suitable for both the Dutch tort law model presented before (\cite{Verheij2017Formalizing}) and the new Chinese copyright infringement model. Compared with the original hand-made modeling way, the program supports the reduction of mistakes made during the process of modeling, as this program can verify the model automatically. In this way, we have presented the first computational implementation for the case model formalism which can support making the theoretical approach more applicable in a practical environment. 

A remaining puzzle is to control the number of cases in case models. For those people who are unfamiliar with legal statues, an explicit case model can be helpful for them, which means the model needs to contain as much details as possible, such as the official judicial interpretations related to Chinese criminal law. But case models can require large numbers of cases. For instance, there are already 8 scenarios about the elementary proposition ``amount of illegal gains is huge or other especially serious circumstances" mentioned in the Chinese copyright infringement model in the light of relevant judicial interpretations. If all of such specific scenarios are added into the model, the number of cases in this model quickly increases. According to the way of building a model completely based on the case model formalism, all these scenarios will be treated as elementary propositions and they will replace the position of  $\textrm{ihe}$. The number of cases increase by eight times, if we added these specific scenarios to the model directly, which is error prone when the list of cases is developed manually. In future research, keeping the number of cases in control could be investigated, e.g., by providing computational means that do not require the explicit listing of all possible cases. 

The results of this paper shows that an implementation of the case model formalism can be used to support the modeling of a legal domain with a complex argument structure involving combined support and attack. In this way, we have shown a computational connection between cases, rules and arguments, applied to the civil law system of the Netherlands and to criminal law in the Chinese legal system. 
In this way, we contribute to AI and legal reasoning technology that is needed to combine rule-based reasoning, case-based reasoning and argumentation together, paving the way for argumentation technology that bridges cases and rules, as it is common in the law.

\footnotesize
\bibliographystyle{unsrt}
\setcitestyle{round,aysep={},yysep={;}}
\bibliography{AIandLaw}


\end{document}